{"ast":null,"code":"module.exports = authenticationRequestError;\n\nconst {\n  RequestError\n} = require(\"@octokit/request-error\");\n\nfunction authenticationRequestError(state, error, options) {\n  if (!error.headers) throw error;\n  const otpRequired = /required/.test(error.headers[\"x-github-otp\"] || \"\"); // handle \"2FA required\" error only\n\n  if (error.status !== 401 || !otpRequired) {\n    throw error;\n  }\n\n  if (error.status === 401 && otpRequired && error.request && error.request.headers[\"x-github-otp\"]) {\n    if (state.otp) {\n      delete state.otp; // no longer valid, request again\n    } else {\n      throw new RequestError(\"Invalid one-time password for two-factor authentication\", 401, {\n        headers: error.headers,\n        request: options\n      });\n    }\n  }\n\n  if (typeof state.auth.on2fa !== \"function\") {\n    throw new RequestError(\"2FA required, but options.on2fa is not a function. See https://github.com/octokit/rest.js#authentication\", 401, {\n      headers: error.headers,\n      request: options\n    });\n  }\n\n  return Promise.resolve().then(() => {\n    return state.auth.on2fa();\n  }).then(oneTimePassword => {\n    const newOptions = Object.assign(options, {\n      headers: Object.assign(options.headers, {\n        \"x-github-otp\": oneTimePassword\n      })\n    });\n    return state.octokit.request(newOptions).then(response => {\n      // If OTP still valid, then persist it for following requests\n      state.otp = oneTimePassword;\n      return response;\n    });\n  });\n}","map":null,"metadata":{},"sourceType":"script"}