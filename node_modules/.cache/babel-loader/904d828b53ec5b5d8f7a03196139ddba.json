{"ast":null,"code":"\"use strict\";\n\nmodule.exports = validate;\n\nconst {\n  RequestError\n} = require(\"@octokit/request-error\");\n\nconst get = require(\"lodash.get\");\n\nconst set = require(\"lodash.set\");\n\nfunction validate(octokit, options) {\n  if (!options.request.validate) {\n    return;\n  }\n\n  const {\n    validate: params\n  } = options.request;\n  Object.keys(params).forEach(parameterName => {\n    const parameter = get(params, parameterName);\n    const expectedType = parameter.type;\n    let parentParameterName;\n    let parentValue;\n    let parentParamIsPresent = true;\n    let parentParameterIsArray = false;\n\n    if (/\\./.test(parameterName)) {\n      parentParameterName = parameterName.replace(/\\.[^.]+$/, \"\");\n      parentParameterIsArray = parentParameterName.slice(-2) === \"[]\";\n\n      if (parentParameterIsArray) {\n        parentParameterName = parentParameterName.slice(0, -2);\n      }\n\n      parentValue = get(options, parentParameterName);\n      parentParamIsPresent = parentParameterName === \"headers\" || typeof parentValue === \"object\" && parentValue !== null;\n    }\n\n    const values = parentParameterIsArray ? (get(options, parentParameterName) || []).map(value => value[parameterName.split(/\\./).pop()]) : [get(options, parameterName)];\n    values.forEach((value, i) => {\n      const valueIsPresent = typeof value !== \"undefined\";\n      const valueIsNull = value === null;\n      const currentParameterName = parentParameterIsArray ? parameterName.replace(/\\[\\]/, `[${i}]`) : parameterName;\n\n      if (!parameter.required && !valueIsPresent) {\n        return;\n      } // if the parent parameter is of type object but allows null\n      // then the child parameters can be ignored\n\n\n      if (!parentParamIsPresent) {\n        return;\n      }\n\n      if (parameter.allowNull && valueIsNull) {\n        return;\n      }\n\n      if (!parameter.allowNull && valueIsNull) {\n        throw new RequestError(`'${currentParameterName}' cannot be null`, 400, {\n          request: options\n        });\n      }\n\n      if (parameter.required && !valueIsPresent) {\n        throw new RequestError(`Empty value for parameter '${currentParameterName}': ${JSON.stringify(value)}`, 400, {\n          request: options\n        });\n      } // parse to integer before checking for enum\n      // so that string \"1\" will match enum with number 1\n\n\n      if (expectedType === \"integer\") {\n        const unparsedValue = value;\n        value = parseInt(value, 10);\n\n        if (isNaN(value)) {\n          throw new RequestError(`Invalid value for parameter '${currentParameterName}': ${JSON.stringify(unparsedValue)} is NaN`, 400, {\n            request: options\n          });\n        }\n      }\n\n      if (parameter.enum && parameter.enum.indexOf(String(value)) === -1) {\n        throw new RequestError(`Invalid value for parameter '${currentParameterName}': ${JSON.stringify(value)}`, 400, {\n          request: options\n        });\n      }\n\n      if (parameter.validation) {\n        const regex = new RegExp(parameter.validation);\n\n        if (!regex.test(value)) {\n          throw new RequestError(`Invalid value for parameter '${currentParameterName}': ${JSON.stringify(value)}`, 400, {\n            request: options\n          });\n        }\n      }\n\n      if (expectedType === \"object\" && typeof value === \"string\") {\n        try {\n          value = JSON.parse(value);\n        } catch (exception) {\n          throw new RequestError(`JSON parse error of value for parameter '${currentParameterName}': ${JSON.stringify(value)}`, 400, {\n            request: options\n          });\n        }\n      }\n\n      set(options, parameter.mapTo || currentParameterName, value);\n    });\n  });\n  return options;\n}","map":null,"metadata":{},"sourceType":"script"}